# -*- coding: utf-8 -*-
"""Cribbage.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11v6NrqvM4NI5rGNyu7MGLZIuAfbHakBK
"""

import numpy as np
import random

"""
Reference Notes

Cards, when dealt, are represented by a number from 0-51.
Spades: 0-12
Diamonds: 13-25
Clubs: 26-38
Hearts: 39-51

Numbering of cards increases from A to K (i.e. Ace of Spades is 0, King of Spades is 12)

We turn the raw integers into a 2 element array of the form [number, suit].

When calculating guaranteed points, we use a "dead card", equal to [-2,-1] (negative 2 of antispades) as the cut card in any point counting function that requires it.
We note that this card cannot form pairs or flushes as the suit and number don't exist in the deck, nor can it form runs with real cards.
"""

#Constants for printing cards
SUITS = ["\u2660","\u2666","\u2663","\u2665"]
NUMBERS = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"]

#This card is used as a replacement for the cut card when we want to ignore the cut card in counting points
VOID_CARD = [-2,-1]

#Constants relating to opponent text
OPPONENTS = ["Jasper", "Merlin", "Max", "Maisy", "Milo"]
LOSING_MESSAGES = ["Ah darn, I lost. I had a lot of fun though!", "Good game. I'm going to sunbathe now.", "C", "D", "E"] #Temporary Placeholders, to be written later
WINNING_MESSAGES = ["I won!? Yipeeeeeeeeeee!", "Thanks for going easy on me. It gave me a good opportunity to rest.", "C", "D", "E"] #Temporary Placeholders, to be written as bots are coded in

VALID_INPUTS = ["1","2","3","4","5","6"]


#Gameplay Loop Functions
def dealHands():
  dealt = random.sample(range(52),13) #Generate 12 random numbers to represent dealt cards, the thirteenth card is the cut card
  n1 = dealt[0:6] #Player's hand (raw integers)
  n2 = dealt[6:12] #Opponent's hand (raw integers)

  p1 = []
  p2 = []
  for n in n1:
    if (p1 == []):
      p1 = [[n%13, int(np.floor(n/13))]]
    else:
      p1.append([n%13, int(np.floor(n/13))])

  for n in n2:
    if (p2 == []):
      p2 = [[n%13, int(np.floor(n/13))]]
    else:
      p2.append([n%13, int(np.floor(n/13))])

  cut = [dealt[12]%13, int(np.floor(dealt[12]/13))] #Cut card
  return p1,p2,cut

#Calculating Points from Tricks
def countPairs(hand, cut):
  """
  Counts points from pairs in hand (plus cut card)

  When calculating guaranteed score, we throw in cut card equal to [-2,-1] (so the number cannot match any card in hand).
  """
  points = 0
  for card1 in hand:
    for card2 in hand:
      if(card1 != card2 and card1[0] == card2[0]):
        points += 1 #Pairs award two points but these loops count each pair twice.
    if (card1[0] == cut[0]):
      points += 2 #Check if each card and cut card make a pair.
  return points

def countFifteens(hand, cut):
  """
  Count points from fifteens in hand (plus cut card)
  """
  points = 0
  for a in range(2):
    for b in range(2):
      for c in range(2):
        for d in range(2):
          sum = a*np.min([hand[0][0]+1,10]) + b*np.min([hand[1][0]+1,10]) + c*np.min([hand[2][0]+1,10]) + d*np.min([hand[3][0]+1,10])
          if (sum == 15 or sum + np.min([cut[0] + 1,10]) == 15):
            points += 2
  return points

def countRuns(hand):
  """
  Count points from runs in hand.

  This function assumes that there are exactly five cards in hand (four plus the cut card)

  If we calculate guaranteed points, the cut card is meaningless. We throw in cut card equal to [-2,-1] (so the cut card cannot form any run with any cards in hand)
  """
  points = 0
  high = 0
  low = 0
  for card1 in hand:
    lowest = True
    run3 = False
    run4 = False
    run5 = False
    for card in hand:
      if(card[0] == card1[0] -1): #This checks if card1 is the lowest card in a run
        lowest = False
    if lowest:
      for card2 in hand:
        if(card1 != card2) and (card1[0] == card2[0]-1):
          high = np.max([card1[0], card2[0]])
          low = np.min([card1[0], card2[0]])
          for card3 in hand:
            if(card3 != card1 and card3 != card2) and (card3[0] == high + 1):
              high = np.max([high, card3[0]])
              low = np.min([low, card3[0]])
              for card4 in hand:
                if(card4 != card1 and card4 != card2 and card4 != card3) and (card4[0] == high + 1):
                  high = np.max([high, card4[0]])
                  low = np.min([low, card4[0]])
                  run4 = True
                  for card5 in hand:
                    if(card5 != card1 and card5 != card2 and card5 != card3 and card5 != card4) and (card5[0] == high + 1):
                      high = np.max([high, card5[0]])
                      low = np.min([low, card5[0]])
                      points += 5
                      run5 = True
                  if (run5 == False):
                    points += 4
              if(run4 == False):
                points += 3
  return int(np.round(points))

def countFlush(hand, cut):
  """
  Count points from flushes in hand, plus cut card.

  By cribbage rules, flushes only count if all cards in your hand are the same suit.

  If cut card is also same suit, flush awards five points instead of four.

  If we calculate guaranteed points, the cut card is meaningless. We throw in cut card equal to [-2,-1] (so the suit cannot match any card in hand).
  """
  if (hand[0][1] == hand[1][1] == hand[2][1] == hand[3][1]):
    if (hand[0][1] == cut[1]):
      return 5
    else:
      return 4
  return 0

def countNobs(hand, cut):
  """
  Count points from nobs in hand
  """
  for card in hand:
    if (card[0] == 10) and (card[1] == cut[1]):
      return 1
  return 0

def calculateScore(hand, cut, out):
  """
  Calculate total points for hand plus cut card
  """
  modHand = hand[:]
  modHand.append(cut)
  pair = countPairs(hand,cut)
  fifteens = countFifteens(hand,cut)
  runs = countRuns(modHand)
  flush = countFlush(hand,cut)
  nobs = countNobs(hand,cut)
  if out:
    print("Pair Points:", pair)
    print("Fifteen Points:", fifteens)
    print("Run Points:", runs)
    print("Flush Points:", flush)
    print("Nobs Points:", nobs)
  return countPairs(hand, cut) + countFifteens(hand,cut) + countRuns(modHand) + countFlush(hand, cut) + countNobs(hand, cut)

#Forth Phase Score Calculation
def calculateStackRun(stack):
  """
  Check if the cards in stack form a run.
  """
  run = [minimumCard(stack)] #Start run at lowest card, building run in ascending order.
  unused = stack[:]
  for i in range(run[0]+1,len(stack)+run[0]):
    for card in unused:
      if (card[0] == run[-1]):
        unused.pop(unused.index(card))
      if (card[0] == i):
        run.append(card[0])
        break

  return len(run) == len(stack) #If our run and stack are the same size, the stack forms a run.

#Utility Functions
def printHand(hand):
  """
  Print cards in hand in clean format.
  Ex. [0,1] becomes Ace of Diamonds
  """
  i = 1
  for card in hand:
    print(f"{i}: {NUMBERS[card[0]]}{SUITS[card[1]]}")
    i += 1

def minimumCard(hand):
  """
  Find the minimum value of cards in hand.

  Ex. If hand is Ace, Jack, King, 9, this function returns 1.
  """

  min = 14
  for card in hand:
    if (card[0] < min):
      min = card[0]
  return min

#COM Behaviours
def opponentDiscard(oppHand, choice):
  """
  Decides which two cards the opponent sends to the crib.
  """
  if choice == 1:
    q = random.sample(range(6),1)
    n = q[0]
    card = oppHand.pop(n)
    cribCards = [card]
    q = random.sample(range(5),1)
    n = q[0]
    card = oppHand.pop(n)
    cribCards.append(card)
    return oppHand, cribCards
  if choice == 2:
    max = 0
    discards = [oppHand[0],oppHand[1]] #If no hands score any guaranteed points, throw the first two cards.
    for card1 in oppHand:
      for card2 in oppHand:
        if (card1 == card2):
          break
        hand = oppHand[:]
        hand.remove(card1)
        hand.remove(card2)
        score = calculateScore(hand, VOID_CARD, False)
        if (score > max):
          max = score
          discards = [card1,card2]
    oppHand.remove(discards[0])
    oppHand.remove(discards[1])
    cribCards = discards
    return oppHand, cribCards


def opponentForth(stack, oppUnplayed, sum, choice):
  """
  Decides which card opponent plays during forth play.
  """

  if choice == 1:
    q = random.sample(range(len(oppUnplayed)),1)
    n=q[0]
    card = oppUnplayed[n]
    while (np.min([card[0] + 1,10]) + sum > 31):
      q = random.sample(range(len(oppUnplayed)),1)
      n = q[0]
      card = oppUnplayed[n]

  elif choice == 2:
    card = oppUnplayed[0] #This may not be a playable card, but reaching this function implies there is a playable card, which will replace this eventually.
    maxPriority = 0 #Until we check the playability of this card, assume it is not playable (priority 0)
    for card1 in oppUnplayed:
      newStack = stack[:]
      newStack.append(card1)
      if(np.min([card1[0] + 1, 10]) + sum > 31):
        priority = 0 #If we can't play this card, what tricks it can form are irrelevant.
      elif(card1[0] == stack[-1][0] and stack[-2][0] == card1[0]): #Check for triples (priority 5). A card can form quads only if it forms triples with the last 2 cards, so we need not check for quads.
        priority = 5
      elif(calculateStackRun(newStack[-3:])): #Check for runs (priority 4)
        priority = 4
      elif(np.min([card1[0]+1,10]) + sum == 15 or np.min([card[0]+1,10]) + sum == 31): #Check for 15s, 31s (priority 3)
        priority = 3
      elif(card1[0] == stack[-1][0]): #Check for pairs (priority 2)
        priority = 2
      else: #Any other card, forming no tricks with the stack (priority 1)
        priority = 1

      if(priority > maxPriority):
        maxPriority = priority
        card = card1

  stack.append(card)
  oppUnplayed.pop(n)
  sum += np.min([card[0] + 1,10])
  return stack, oppUnplayed, sum

def reportScores(pScore, oScore, choice):
  """
  Gives the current score and lead.
  """
  if (pScore > oScore):
    print(f"The score is now {pScore}-{oScore} (You lead by {pScore-oScore} points)")

  elif (pScore == oScore):
    print(f"The score is now {pScore}-{oScore} (Draw game)")

  else:
    print(f"The score is now {pScore}-{oScore} ({OPPONENTS[choice-1]} leads by {oScore-pScore} points)")

#Gameplay Functions
def gameLoop(playerHand, oppHand, cut, crib, pScore, oScore, choice):
  #Phase 1: Discarding two cards in hand
  print("You are dealt six cards as follows:")
  printHand(playerHand)
  print("Please type the index of the first card you wish to send to the crib:")
  q = input()
  while (q not in VALID_INPUTS):
    print("Invalid input. Please choose a valid option from 1 to 6.")
    q = input()

  n = int(q)
  card = playerHand.pop(n-1)
  cribHand = [card]
  print("Your hand is now:")
  printHand(playerHand)
  print("Please type the index of the second card you wish to send to the crib:")
  q = input()
  while (q not in VALID_INPUTS[0:5]):
    print("Invalid input. Please choose a valid option from 1 to 5.")
    q = input()

  n = int(q)
  card = playerHand.pop(n-1)
  cribHand.append(card)

  #Opponent throws two cards.
  print(f"{OPPONENTS[choice-1]} throws two cards into the crib.")
  oppHand, cribCards = opponentDiscard(oppHand, choice)
  cribHand.append(cribCards[0])
  cribHand.append(cribCards[1])

  #Phase 2: Reveal cut card. Back and Forth Play
  print("The cut card is revealed to be",NUMBERS[cut[0]], SUITS[cut[1]])
  if cut[0] == 10:
    if crib == 0:
      print("Heels! You get 2 points for turning up a Jack.")
      pScore += 2
      reportScores(pScore, oScore, choice)
      if pScore > 120:
        return pScore, oScore
    if crib == 1:
      print(f"Heels! {OPPONENTS[choice-1]} gets 2 points for turning up a Jack.")
      oScore += 2
      reportScores(pScore, oScore, choice)
      if oScore > 120:
        return pScore, oScore

  player_left = playerHand[:]
  opp_left = oppHand[:]
  stack = []
  turn = crib #Marks whose turn it is

  sum = 0 #Running sum for forth phase

  passed = 0 #Indicator for which player has passed their turn.

  while (player_left != [] or opp_left != []):
    if (turn == 0):
      if (np.min([minimumCard(player_left)+1,10]) + sum > 31):
        print("None of your remaining cards can be played. You pass your turn.")
        if (passed == 0):
          passed = 1
        elif (passed == 2):
          print("You get a point for playing last on the stack.")
          stack = []
          sum = 0
          pScore += 1
        turn = 1

      elif(player_left == []):
        print("You have no cards left. You pass your turn.")
        if (passed == 0):
          passed = 1
        elif (passed == 2):
          print("You get a point for playing last on the stack.")
          pScore += 1
          stack = []
          sum = 0
        turn = 1
      else:
        print("The stack is currently:")
        printHand(stack)
        print("Your remaining cards are:")
        printHand(player_left)
        print("Please type the index of the card that you wish to play:")
        q = input()
        while (q not in VALID_INPUTS[0:len(player_left)]):
          print(f"Invalid input. Please choose an option between 1 and {len(player_left)}")
          q = input()
        n = int(q)
        card = player_left[n-1]
        while(np.min([card[0]+1,10]) + sum > 31):
          print("This card cannot be discarded as the sum will be above 31. Please choose a new card.")
          q = input()
          while (q not in VALID_INPUTS[0:len(player_left)]):
            print(f"Invalid input. Please choose an option between 1 and {len(player_left)}")
            q = input()
          n = int(q)
          card = player_left[n-1]
        player_left.pop(n-1)
        stack.append(card)
        sum += np.min([card[0] + 1,10])
        print(f"You play {NUMBERS[stack[-1][0]]}{SUITS[stack[-1][1]]}, bringing the sum to {sum}.")

        #Check for tricks
        if (sum == 15):
          print("Fifteen for two!")
          pScore += 2

        if (len(stack) > 1 and stack[-1][0] == stack[-2][0]):
          if (len(stack) > 2 and stack[-1][0] == stack[-3][0]):
            if (len(stack) > 3 and stack[-1][0] == stack[-4][0]):
              print("Four of a kind for twelve points!")
              pScore += 12
            else:
              print("Three of a kind for six points!")
              pScore += 6
          else:
            print("Pair for two points!")
            pScore += 2

        runScore = 0
        for i in range(3, len(stack)+1): #Check all consecutive cards at top of stack for runs.
          if(calculateStackRun(stack[-i:])):
            runScore = i

        pScore += runScore
        if (runScore > 0):
          print("You score a run for", runScore, "points!")


        if (sum == 31):
          print("Thirty one for two!")
          pScore += 2
          stack = []
          sum = 0

        reportScores(pScore, oScore, choice)

        if pScore > 120:
          return pScore, oScore
        turn = 1

      if (pScore > 120):
        return pScore, oScore

    elif (turn == 1):

      if (np.min([minimumCard(opp_left)+1,10]) + sum > 31):
        print(f"None of {OPPONENTS[choice-1]}'s remaining cards can be played. They pass their turn.")
        if (passed == 0):
          passed = 2
        elif (passed == 1):
          print(f"{OPPONENTS[choice-1]} gets a point for playing last on the stack.")
          oScore += 1
          stack = []
          sum = 0
        turn = 0

      elif(opp_left == []):
        print(f"{OPPONENTS[choice-1]} has no cards left. They pass their turn.")
        if (passed == 0):
          passed = 2
        elif (passed == 1):
          print(f"{OPPONENTS[choice-1]} gets a point for playing last on the stack.")
          oScore += 1
          stack = []
          sum = 0
        turn = 0

      else:
        stack, oppUnplayed, sum = opponentForth(stack, opp_left, sum, choice) #Opponent decides which card to play

        print(f"{OPPONENTS[choice-1]} plays {NUMBERS[stack[-1][0]]}{SUITS[stack[-1][1]]},  bringing the sum to {sum}.")

        if (sum ==15):
          print("Fifteen for two!")
          oScore += 2

        if (len(stack) > 1 and stack[-1][0] == stack[-2][0]):
          if (len(stack) > 2 and stack[-1][0] == stack[-3][0]):
            if (len(stack) > 3 and stack[-1][0] == stack[-4][0]):
              print("Four of a kind for twelve points!")
              oScore += 12
            else:
              print("Three of a kind for six points!")
              oScore += 6
          else:
            print("Pair for two points!")
            oScore += 2

        runScore = 0
        for i in range(3, len(stack)+1): #Check all consecutive cards at top of stack for runs.
          if(calculateStackRun(stack[-i:])):
            runScore = i

        oScore += runScore
        if (runScore > 0):
          print(f"{OPPONENTS[choice-1]} scores a run for", runScore, "points!")

        if (sum == 31):
          print("Thirty one for two!")
          oScore += 2
          stack = []
          sum = 0

        reportScores(pScore, oScore, choice)

        if oScore > 120:
          return pScore, oScore

        turn = 0

      if (oScore > 120):
        return pScore, oScore


  #Phase 3: Count points in hands and crib.

  if (crib == 0):
    points = calculateScore(oppHand, cut, True)
    oScore += points
    print(f"{OPPONENTS[choice-1]} reveals their hand:")
    printHand(oppHand)
    print(f"{OPPONENTS[choice-1]} scores {points} points from their hand.")
    reportScores(pScore, oScore, choice)
    if (oScore > 120):
      return pScore, oScore

    points = calculateScore(playerHand, cut, True)
    pScore += points
    print(f"You score {points} points from your hand.")
    reportScores(pScore, oScore, choice)
    if (pScore > 120):
      return pScore, oScore
    points = calculateScore(cribHand,cut, True)
    pScore += points
    print("The crib is:")
    printHand(cribHand)
    print(f"You also score {points} points from the crib.")
    reportScores(pScore, oScore, choice)
    if (pScore > 120):
      return pScore, oScore

  elif (crib == 1):
    points = calculateScore(playerHand, cut, True)
    pScore += points
    print(f"You score {points} points from your hand.")
    reportScores(pScore, oScore, choice)
    if (pScore > 120):
      return pScore, oScore

    points = calculateScore(oppHand, cut, True)
    oScore += points
    print(f"{OPPONENTS[choice-1]} reveals their hand:")
    printHand(oppHand)
    print(f"{OPPONENTS[choice-1]} scores {points} points from their hand.")
    reportScores(pScore, oScore, choice)
    if (oScore > 120):
      return pScore, oScore
    points = calculateScore(cribHand,cut, True)
    oScore += points
    print("The crib is:")
    printHand(cribHand)
    print(f"They also score {points} points from the crib.")
    reportScores(pScore, oScore, choice)
    if (oScore > 120):
      return pScore, oScore

  return pScore, oScore

def game():
  """
  Main function to activate game of cribbage.
  """
  print("Welcome to Cribbage With Cats!")
  print("Before we start, what is your name?")
  name = input()
  print(f"Well then, {name}, who would you like to play today?")
  print("Please input the number of your choice:")
  print("1: Jasper (easy)")
  print("2: Merlin (safety player)")
  print("3: Max (opportunist) - Asleep")
  print("4: Maisy (statistician) - Asleep")
  print("5: Milo (unfair) - Asleep")

  l = input()

  while(l != "1" and l != "2" and l != "3" and l != "4" and l != "5"):
    print("Invalid choice. Please choose a valid option from 1 to 5.")
    l = input()

  choice = int(l)

  while(choice != 1 and choice != 2):
    if choice == 3:
      print("Max has been selected.")
      print("Max is currently pestering people in the kitchen for food.")
      print("Trust me, you don't want to get between Max and his food. See if another opponent is free to play while you wait.")
      #print("'Yay! Someone to play games with!'")
      #print("Max begins cleaning himself. How uncivilized.")

    elif choice == 4:
      print("Maisy has been selected.")
      print("Unfortunately, it looks like she's sleeping on one of Alec's math textbooks.")
      print("Please pick another opponent, or wait for Maisy to wake up.")
      #print("'I've been sleeping on Alec's bookshelf, reading his math books. I am now the best statistical cribbage player of all time.'")
      #print("Maisy pulls out a calculator. Can she even operate it without posable thumbs?")

    if choice == 5:
      print("Milo has been selected.")
      print("Milo seems to be busy waiting around a corner waiting to attack the ankles of any passerby.")
      print("Perhaps it would be best not to approach him right now and find someone else to play.")
      #print("'I'm not looking at your cards. I don't know what you're talking about.'")
      #print("Milo is, in fact, looking at your cards, and doing a poor job hiding it.")

    print("Please input the number of an awake cat:")
    print("1: Jasper (easy)")
    print("2: Merlin (safety player)")

    l = input()

    while(l != "1" and l != "2" and l != "3" and l != "4" and l != "5"):
      print("Invalid choice. Please choose a valid option from 1 to 5.")
      l = input()

    choice = int(l)

  if choice == 1:
    print("Jasper has been selected.")
    print("'Let's have some fun playing... uh... what are we playing again?'")
    print("Jasper accidentally knocks the entire deck of cards off the table, sending them scattering across the floor, face up")

  elif choice == 2:
    print("Merlin has been selected.")
    print("'What a nice way to unwind. Let's have a nice, laid back game.'")
    print("Merlin practically unhinges his jaw to let out a massive yawn.")

  player_score = 0
  opp_score = 0

  m = random.sample(range(2),1)
  crib = m[0]

  if (crib == 0):
    print("You win the coin flip, you have first crib.")

  elif (crib== 1):
    print("You lose the coin flip,",OPPONENTS[choice-1],"has first crib.")

  while (player_score < 121 and opp_score < 121):
    playerHand, oppHand, cut = dealHands()
    player_score, opp_score = gameLoop(playerHand, oppHand, cut, crib, player_score, opp_score, choice)
    crib = (crib+1) % 2

  if(opp_score > player_score):
    print("You have been bested by", OPPONENTS[choice-1])
    print(LOSING_MESSAGES[choice-1])

    if (choice == "1"):
      print("**************************************************************************")
      print("ACHIEVEMENT 1 UNLOCKED: REALLY???")
      print("Lose to Jasper, an opponent who plays completely randomly")
      print("**************************************************************************")

  else:
    print("You have defeated", OPPONENTS[int(choice)-1])
    print(WINNING_MESSAGES[int(choice)-1])
    if (choice == "1"):
      print("**************************************************************************")
      print("ACHIEVEMENT 2 UNLOCKED: BETTER THAN A COIN")
      print("Best Jasper, proving that you can beat a set of dice in cribbage.")
      print("**************************************************************************")

    if (choice == "2"):
      print("**************************************************************************")
      print("ACHIEVEMENT 3 UNLOCKED: SAFETY DANCE")
      print("Best Merlin.")
      print("**************************************************************************")
      if (opp_score < 91):
        print("**************************************************************************")
        print("ACHIEVEMENT 7 UNLOCKED: SAFETY IS FOR THE WEAK")
        print("Skunk Merlin.")
        print("**************************************************************************")

game()